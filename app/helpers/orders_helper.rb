module OrdersHelper
  def order_customisation(order)
    description = order.customisation_description
    content_tag(:span, truncate(description), title: description)
  end

  def order_extras(order)
    description = order.extras_description(true)
    content_tag(:span, truncate(description), title: description)
  end

  def order_frequencies
    ScheduleRule::RECUR.map { |frequencies| [frequencies.to_s.titleize, frequencies.to_s] }
  end

  def order_schedule(order)
    if order.recurs?
      order.schedule_rule.to_s
    else
      "Deliver on #{order.next_occurrence.strftime("%A")}"
    end
  end

  # Show the orders next delivery dates, link to the delivery screen if it is within the forcast range
  def orders_next_deliveries(order, options = {})
    options = { with_link: true }.merge(options)

    order_occurrences = order.next_occurrences(5, Date.current).map do |day|
      formatted_day = day.to_s(:flux_cap)

      if options[:with_link] && day <= Order::FORCAST_RANGE_FORWARD.from_now.to_date
        link_to(formatted_day, date_distributor_deliveries_path(day, order.route))
      else
        formatted_day
      end
    end

    unless order_occurrences.empty?
      order_occurrences.join(', ').html_safe
    end
  end

  def order_pause_date_formatted(order)
    date = order.pause_date
    return date ? date.to_s(:pause) : ''
  end

  def order_resume_date_formatted(order)
    date = order.resume_date
    return date ? date.to_s(:pause) : ''
  end

  def all_order_start_dates(distributor, count = 14)
    next_occurrences = distributor.routes.inject([]) { |a,r| a += order_start_dates(r, count); a }
    return next_occurrences.uniq.sort{ |a,b| a[1] <=> b[1] }
  end

  def order_start_dates(route, time_from_now = nil)
    time_from_now ||= 12.weeks.from_now
    from_time = route.distributor.window_end_at + 1.day #next_occurrence includes the start date, so choose the next day
    next_occurrences = route.occurrences_between(from_time, time_from_now)
    return next_occurrences.map { |time| [time.to_s(:route_delivery_dates), time.to_date] }
  end

  def order_delete_warning(order)
    no_deliveries_confirm = "Are you sure you would like to deactivate this order? It will no longer generate deliveries."
    deliveries_confirm = "WARNING\r\rSorry some deliveries generated by this order could not be deleted as they are already for packing and delivery."

    return order.has_yellow_deliveries? ? deliveries_confirm : no_deliveries_confirm
  end

  def order_dates_grid
    days = []
    4.times do |week| # 4 first weeks of the month
      days << ScheduleRule::DAYS.map do |day|
        [day.to_s.titleize, ScheduleRule::DAYS.index(day) + ScheduleRule::DAYS.size * week]
      end
    end
    days
  end
end

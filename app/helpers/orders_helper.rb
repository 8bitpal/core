module OrdersHelper
  def order_customisation(order)
    description = order.customisation_description
    content_tag(:span, truncate(description), title: description)
  end

  def order_extras(order)
    description = order.extras_description(true)
    content_tag(:span, truncate(description), title: description)
  end

  def order_frequencies
    Order::FREQUENCIES.map { |frequencies| [frequencies.titleize, frequencies] }
  end

  def order_delete_warning(order)
    no_deliveries_confirm = "Are you sure you would like to deactivate this order? It will no longer generate deliveries."
    deliveries_confirm = "WARNING\r\rSorry some deliveries generated by this order could not be deleted as they are already for packing and delivery."

    order.deliveries.size > 0 ? deliveries_confirm : no_deliveries_confirm
  end

  def order_schedule(order, options = {})
    joiner = (options[:join_with].nil? ? '<br/>' : options[:join_with])
    schedule = order.schedule
    string_schedule = []

    unless options[:recurrence_rules] == false || schedule.recurrence_rules.empty?
      string_schedule << schedule.recurrence_rules.join(', ')
    end

    unless options[:recurrence_times] == false || schedule.recurrence_times.empty?
      string_schedule << 'Single delivery order'
    end

    unless options[:exception_rules] == false || schedule.exception_rules.empty?
      string_schedule << schedule.exception_rules.join(', ')
    end

    unless options[:exception_times] == false || schedule.exception_times.empty?
      et = schedule.exception_times
      first_et = et.first
      last_et = (et.last + 1.day) # this is shown as the resume day so a day after the last exception date
      exception_times = "pausing on #{first_et.to_s(:month_date_year)}#{joiner}resuming on #{last_et.to_s(:month_date_year)}".html_safe
      string_schedule << "#{link_to exception_times, '#', data: {'reveal-id' => "pause-modal-#{order.id}"}}"
    end

    return string_schedule.join(joiner).html_safe
  end

  def order_pause_select(order)
    start_time = Time.now
    end_time = start_time + 8.weeks
    select_array = order.schedule.occurrences(end_time, start_time).map { |s| [s.to_date.to_s(:pause), s.to_date] }

    existing_pause_start = order_pause_start_date(order)

    if existing_pause_start && !select_array.index(existing_pause_start)
      select_array << [existing_pause_start.to_s(:pause), existing_pause_start]
      select_array.sort! { |a,b| a.second <=> b.second }
    end

    return select_array
  end

  def order_resume_select(order)
    start_time = Time.now
    end_time = start_time + 12.weeks
    select_array = order.schedule.occurrences(end_time, start_time).map { |s| [s.to_date.to_s(:pause), s.to_date] }

    existing_pause_end = order_pause_end_date(order)

    if existing_pause_end && !select_array.index(existing_pause_end)
      select_array << [existing_pause_end.to_s(:pause), existing_pause_end]
      select_array.sort! { |a,b| a.second <=> b.second }
    end

    return select_array
  end

  def order_pause_start_date(order)
    date = order.schedule.exception_times.first
    date = date.to_date if date
    return date
  end

  def order_pause_start_date_formatted(order)
    date = order_pause_start_date(order)
    return date.nil? ? '' : date.to_s(:pause)
  end

  def order_pause_end_date(order)
    date = order.schedule.exception_times.last
    date = date.to_date + 1.day if date # the +1 day is shown as the resume day so a day after the last exception date
    return date
  end

  def order_pause_end_date_formatted(order)
    date = order_pause_end_date(order)
    return date.nil? ? '' : date.to_s(:pause)
  end
end
